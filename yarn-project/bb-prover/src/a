test/a_nested_exceptional_halt_is_recovered_from_in_caller.test.ts
import { proveAndVerifyAvmTestContractSimple } from './prove_and_verify.js';

const TIMEOUT = 300_000;

it(
  'a nested exceptional halt is recovered from in caller',
  async () => {
    await proveAndVerifyAvmTestContractSimple(
      /*checkCircuitOnly=*/ true, // quick
      'external_call_to_divide_by_zero_recovers',
      /*args=*/ [],
      /*expectRevert=*/ false,
    );
  },
  TIMEOUT,
);
test/a_nested_exceptional_halt_propagate_to_top_level.test.ts
import { proveAndVerifyAvmTestContractSimple } from './prove_and_verify.js';

const TIMEOUT = 300_000;

it(
  'a nested exceptional halt propagate to top-level',
  async () => {
    await proveAndVerifyAvmTestContractSimple(
      /*checkCircuitOnly=*/ true, // quick
      'external_call_to_divide_by_zero',
      /*args=*/ [],
      /*expectRevert=*/ true,
    );
  },
  TIMEOUT,
);
test/a_top_level_exceptional_halts_due_to_non_existent_contract_in_app_logic_and_teardown.test.ts
import { Fr } from '@aztec/foundation/fields';

import { proveAndVerifyAvmTestContract } from './prove_and_verify.js';

const TIMEOUT = 300_000;

// This test is skipped in the original file due to "Lookup PERM_MAIN_ALU failed."
it.skip(
  'a top-level exceptional halts due to a non-existent contract in app-logic and teardown',
  async () => {
    await proveAndVerifyAvmTestContract(
      /*checkCircuitOnly=*/ true,
      /*setupFunctionNames=*/ [],
      /*setupArgs=*/ [],
      /*appFunctionNames=*/ ['add_args_return'],
      /*appArgs=*/ [[new Fr(1), new Fr(2)]],
      /*teardownFunctionName=*/ 'add_args_return',
      /*teardownArgs=*/ [new Fr(1), new Fr(2)],
      /*expectRevert=*/ true,
      /*skipContractDeployments=*/ true,
    );
  },
  TIMEOUT,
);
test/an_exceptional_halt_due_to_nested_call_to_non_existent_contract_is_recovered_from_in_caller.test.ts
import { proveAndVerifyAvmTestContractSimple } from './prove_and_verify.js';

const TIMEOUT = 300_000;

it(
  'an exceptional halt due to a nested call to non-existent contract is recovered from in caller',
  async () => {
    await proveAndVerifyAvmTestContractSimple(
      /*checkCircuitOnly=*/ true, // quick
      'nested_call_to_nothing_recovers',
      /*args=*/ [],
      /*expectRevert=*/ false,
    );
  },
  TIMEOUT,
);
test/an_exceptional_halt_due_to_nested_call_to_non_existent_contract_propagated_to_top_level.test.ts
import { proveAndVerifyAvmTestContractSimple } from './prove_and_verify.js';

const TIMEOUT = 300_000;

it(
  'an exceptional halt due to a nested call to non-existent contract is propagated to top-level',
  async () => {
    await proveAndVerifyAvmTestContractSimple(
      /*checkCircuitOnly=*/ true, // quick
      'nested_call_to_nothing',
      /*args=*/ [],
      /*expectRevert=*/ true,
    );
  },
  TIMEOUT,
);
test/attempt_too_many_calls_to_unique_contract_class_ids.test.ts
import { Fr } from '@aztec/foundation/fields';
import { MockedAvmTestContractDataSource } from '@aztec/simulator/public/fixtures';

import { proveAndVerifyAvmTestContractSimple } from './prove_and_verify.js';

const TIMEOUT = 300_000;

it(
  'attempt too many calls to unique contract class ids',
  async () => {
    const contractDataSource = new MockedAvmTestContractDataSource();
    // args is initialized to MAX_PUBLIC_CALLS_TO_UNIQUE_CONTRACT_CLASS_IDS+1 contract addresses with unique class IDs
    // should fail because we are trying to call MAX+1 unique class IDs
    const args = Array.from(contractDataSource.contractInstances.values()).map(instance => instance.address.toField());
    // Push an empty one (just padding to match function calldata size)
    args.push(new Fr(0));
    await proveAndVerifyAvmTestContractSimple(
      /*checkCircuitOnly=*/ true, // quick
      'nested_call_to_add_n_times_different_addresses',
      args,
      /*expectRevert=*/ true,
      /*skipContractDeployments=*/ false,
      contractDataSource,
    );
  },
  TIMEOUT,
);
test/bulk_testing_v1.test.ts
import { Fr } from '@aztec/foundation/fields';

import { proveAndVerifyAvmTestContractSimple } from './prove_and_verify.js';

const TIMEOUT = 300_000;

it(
  'bulk_testing v1',
  async () => {
    await proveAndVerifyAvmTestContractSimple(
      /*checkCircuitOnly=*/ false, // full proving & verifying
      'bulk_testing',
      /*args=*/ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10].map(x => new Fr(x)),
    );
  },
  TIMEOUT,
);
test/bulk_testing_v2.test.ts
import { Fr } from '@aztec/foundation/fields';
import { createLogger } from '@aztec/foundation/log';
import { simulateAvmTestContractGenerateCircuitInputs } from '@aztec/simulator/public/fixtures';

import fs from 'node:fs/promises';
import { tmpdir } from 'node:os';
import path from 'path';

import { type BBSuccess, BB_RESULT, generateAvmProofV2, verifyAvmProofV2 } from '../bb/execute.js';

it('bulk_testing v2', async () => {
  const functionName = 'bulk_testing';
  const calldata = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10].map(x => new Fr(x));
  const avmCircuitInputs = await simulateAvmTestContractGenerateCircuitInputs(
    /*setupFunctionNames=*/ [],
    /*setupArgs=*/ [],
    /*appFunctionNames=*/ [functionName],
    /*appArgs=*/ [calldata],
    /*teardownFunctionName=*/ undefined,
    /*teardownArgs=*/ [],
    /*expectRevert=*/ false,
  );

  const logger = createLogger('bb-prover:avm-proving-test');

  // The paths for the barretenberg binary and the write path are hardcoded for now.
  const bbPath = path.resolve('../../barretenberg/cpp/build/bin/bb');
  const bbWorkingDirectory = await fs.mkdtemp(path.join(tmpdir(), 'bb-'));

  // Then we prove.
  const proofRes = await generateAvmProofV2(bbPath, bbWorkingDirectory, avmCircuitInputs, logger);
  if (proofRes.status === BB_RESULT.FAILURE) {
    logger.error(`Proof generation failed: ${proofRes.reason}`);
  }
  expect(proofRes.status).toEqual(BB_RESULT.SUCCESS);
  const succeededRes = proofRes as BBSuccess;

  // Then we verify.
  // Placeholder for now.
  const publicInputs = {
    dummy: [] as any[],
  };

  const rawVkPath = path.join(succeededRes.vkPath!, 'vk');
  const verificationRes = await verifyAvmProofV2(
    bbPath,
    bbWorkingDirectory,
    succeededRes.proofPath!,
    publicInputs,
    rawVkPath,
    logger,
  );
  expect(verificationRes.status).toBe(BB_RESULT.SUCCESS);
}, 180_000);
test/call_the_max_number_of_unique_contract_classes.test.ts
import { MAX_PUBLIC_CALLS_TO_UNIQUE_CONTRACT_CLASS_IDS } from '@aztec/circuits.js';
import { MockedAvmTestContractDataSource } from '@aztec/simulator/public/fixtures';

import { proveAndVerifyAvmTestContractSimple } from './prove_and_verify.js';

const TIMEOUT = 300_000;

it(
  'call the max number of unique contract classes',
  async () => {
    const contractDataSource = new MockedAvmTestContractDataSource();
    // args is initialized to MAX_PUBLIC_CALLS_TO_UNIQUE_CONTRACT_CLASS_IDS contract addresses with unique class IDs
    const args = Array.from(contractDataSource.contractInstances.values())
      .map(instance => instance.address.toField())
      .slice(0, MAX_PUBLIC_CALLS_TO_UNIQUE_CONTRACT_CLASS_IDS);
    // include the first contract again at the end to ensure that we can call it even after the limit is reached
    args.push(args[0]);
    // include another contract address that reuses a class ID to ensure that we can call it even after the limit is reached
    args.push(contractDataSource.instanceSameClassAsFirstContract.address.toField());
    await proveAndVerifyAvmTestContractSimple(
      /*checkCircuitOnly=*/ true, // quick
      'nested_call_to_add_n_times_different_addresses',
      args,
      /*expectRevert=*/ false,
      /*skipContractDeployments=*/ false,
      contractDataSource,
    );
  },
  TIMEOUT,
);
test/create_too_many_l2tol1_messages_and_revert.test.ts
import { MAX_L2_TO_L1_MSGS_PER_TX } from '@aztec/circuits.js';
import { Fr } from '@aztec/foundation/fields';

import { proveAndVerifyAvmTestContractSimple } from './prove_and_verify.js';

const TIMEOUT = 300_000;

it(
  'create too many l2tol1 messages and revert',
  async () => {
    await proveAndVerifyAvmTestContractSimple(
      /*checkCircuitOnly=*/ true, // quick
      'n_new_l2_to_l1_msgs',
      /*args=*/ [new Fr(MAX_L2_TO_L1_MSGS_PER_TX + 1)],
      /*expectRevert=*/ true,
    );
  },
  TIMEOUT,
);
test/create_too_many_note_hashes_and_revert.test.ts
import { MAX_NOTE_HASHES_PER_TX } from '@aztec/circuits.js';
import { Fr } from '@aztec/foundation/fields';

import { proveAndVerifyAvmTestContractSimple } from './prove_and_verify.js';

const TIMEOUT = 300_000;

it(
  'create too many note hashes and revert',
  async () => {
    await proveAndVerifyAvmTestContractSimple(
      /*checkCircuitOnly=*/ true, // quick
      'n_new_note_hashes',
      /*args=*/ [new Fr(MAX_NOTE_HASHES_PER_TX + 1)],
      /*expectRevert=*/ true,
    );
  },
  TIMEOUT,
);
test/create_too_many_nullifiers_and_revert.test.ts
import { MAX_NULLIFIERS_PER_TX } from '@aztec/circuits.js';
import { Fr } from '@aztec/foundation/fields';

import { proveAndVerifyAvmTestContractSimple } from './prove_and_verify.js';

const TIMEOUT = 300_000;

it(
  'create too many nullifiers and revert',
  async () => {
    await proveAndVerifyAvmTestContractSimple(
      /*checkCircuitOnly=*/ true, // quick
      'n_new_nullifiers',
      /*args=*/ [new Fr(MAX_NULLIFIERS_PER_TX + 1)],
      /*expectRevert=*/ true,
    );
  },
  TIMEOUT,
);
test/create_too_many_unencrypted_logs_and_revert.test.ts
import { MAX_UNENCRYPTED_LOGS_PER_TX } from '@aztec/circuits.js';
import { Fr } from '@aztec/foundation/fields';

import { proveAndVerifyAvmTestContractSimple } from './prove_and_verify.js';

const TIMEOUT = 300_000;

it(
  'create too many unencrypted logs and revert',
  async () => {
    await proveAndVerifyAvmTestContractSimple(
      /*checkCircuitOnly=*/ true, // quick
      'n_new_unencrypted_logs',
      /*args=*/ [new Fr(MAX_UNENCRYPTED_LOGS_PER_TX + 1)],
      /*expectRevert=*/ true,
    );
  },
  TIMEOUT,
);
test/enqueued_calls_in_every_phase_with_dependencies.test.ts
import { Fr } from '@aztec/foundation/fields';

import { proveAndVerifyAvmTestContract } from './prove_and_verify.js';

const TIMEOUT = 300_000;

it(
  'enqueued calls in every phase, with enqueued calls that depend on each other',
  async () => {
    await proveAndVerifyAvmTestContract(
      /*checkCircuitOnly=*/ true,
      /*setupFunctionNames=*/ ['read_assert_storage_single', 'set_storage_single'],
      /*setupArgs=*/ [[new Fr(0)], [new Fr(5)]],
      /*appFunctionNames=*/ ['read_assert_storage_single', 'set_storage_single'],
      /*appArgs=*/ [[new Fr(5)], [new Fr(10)]],
      /*teardownFunctionName=*/ 'read_assert_storage_single',
      /*teardownArgs=*/ [new Fr(10)],
    );
  },
  TIMEOUT,
);
test/perform_too_many_storage_writes_and_revert.test.ts
import { MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX } from '@aztec/circuits.js';
import { Fr } from '@aztec/foundation/fields';

import { proveAndVerifyAvmTestContractSimple } from './prove_and_verify.js';

const TIMEOUT = 300_000;

it(
  'perform too many storage writes and revert',
  async () => {
    await proveAndVerifyAvmTestContractSimple(
      /*checkCircuitOnly=*/ true, // quick
      'n_storage_writes',
      /*args=*/ [new Fr(MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX + 1)],
      /*expectRevert=*/ true,
    );
  },
  TIMEOUT,
);
test/should_prove_and_verify_tx_reverts_in_teardown.test.ts
import { Fr } from '@aztec/foundation/fields';

import { proveAndVerifyAvmTestContract } from './prove_and_verify.js';

const TIMEOUT = 300_000;

it(
  'Should prove and verify a TX that reverts in teardown',
  async () => {
    await proveAndVerifyAvmTestContract(
      /*checkCircuitOnly=*/ true,
      /*setupFunctionNames=*/ [],
      /*setupArgs=*/ [],
      /*appFunctionNames=*/ [],
      /*appArgs=*/ [],
      /*teardownFunctionName=*/ 'read_assert_storage_single',
      /*teardownArgs=*/ [new Fr(10)],
      /*expectRevert=*/ true,
    );
  },
  TIMEOUT,
);
test/top_level_exceptional_halt_in_app_logic_but_teardown_succeeds.test.ts
import { Fr } from '@aztec/foundation/fields';

import { proveAndVerifyAvmTestContract } from './prove_and_verify.js';

const TIMEOUT = 300_000;

it(
  'top-level exceptional halt in app logic, but teardown succeeds',
  async () => {
    await proveAndVerifyAvmTestContract(
      /*checkCircuitOnly=*/ true,
      /*setupFunctionNames=*/ [],
      /*setupArgs=*/ [],
      /*appFunctionNames=*/ ['divide_by_zero'],
      /*appArgs=*/ [[]],
      /*teardownFunctionName=*/ 'add_args_return',
      /*teardownArgs=*/ [new Fr(1), new Fr(2)],
      /*expectRevert=*/ true,
    );
  },
  TIMEOUT,
);
test/top_level_exceptional_halt_in_teardown_but_app_logic_succeeds.test.ts
import { Fr } from '@aztec/foundation/fields';

import { proveAndVerifyAvmTestContract } from './prove_and_verify.js';

const TIMEOUT = 300_000;

it(
  'top-level exceptional halt in teardown, but app logic succeeds',
  async () => {
    await proveAndVerifyAvmTestContract(
      /*checkCircuitOnly=*/ true,
      /*setupFunctionNames=*/ [],
      /*setupArgs=*/ [],
      /*appFunctionNames=*/ ['add_args_return'],
      /*appArgs=*/ [[new Fr(1), new Fr(2)]],
      /*teardownFunctionName=*/ 'divide_by_zero',
      /*teardownArgs=*/ [],
      /*expectRevert=*/ true,
    );
  },
  TIMEOUT,
);
test/top_level_exceptional_halts_in_both_app_logic_and_teardown.test.ts
import { Fr } from '@aztec/foundation/fields';

import { proveAndVerifyAvmTestContract } from './prove_and_verify.js';

const TIMEOUT = 300_000;

it(
  'top-level exceptional halts in both app logic and teardown',
  async () => {
    await proveAndVerifyAvmTestContract(
      /*checkCircuitOnly=*/ true,
      /*setupFunctionNames=*/ [],
      /*setupArgs=*/ [],
      /*appFunctionNames=*/ ['divide_by_zero'],
      /*appArgs=*/ [[]],
      /*teardownFunctionName=*/ 'divide_by_zero',
      /*teardownArgs=*/ [],
      /*expectRevert=*/ true,
    );
  },
  TIMEOUT,
);
