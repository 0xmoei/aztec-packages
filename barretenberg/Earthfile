VERSION 0.8

acir-tests-base:
    FROM ../+bootstrap-noir-bb
    ENV PATH="/usr/src/noir/noir-repo/target/release:${PATH}"
    WORKDIR /usr/src/barretenberg/acir_tests
    ENV VERBOSE=1
    RUN mkdir -p ~/.bb-crs
    RUN CI25=1 ./bootstrap.sh build
    ENV RECURSIVE=1
    # Avoid race conditions with bb.
    RUN bash -c 'curl -s -H "Range: bytes=0-$(((2**20+1)*64-1))" https://aztec-ignition.s3.amazonaws.com/MAIN%20IGNITION/flat/g1.dat -o ~/.bb-crs/bn254_g1.dat'

acir-tests-bb:
    FROM +acir-tests-base
    # Fold and verify an ACIR program stack using ClientIvc
    RUN FLOW=fold_and_verify_program ./run_acir_tests.sh fold_basic
    # Fold and verify an ACIR program stack using ClientIvc, then natively verify the ClientIVC proof.
    RUN FLOW=prove_then_verify_client_ivc ./run_acir_tests.sh fold_basic
    # Fold and verify an ACIR program stack using ClientIvc, recursively verify as part of the Tube circuit and produce and verify a Honk proof
    RUN FLOW=prove_then_verify_tube ./run_acir_tests.sh fold_basic
    # Run 1_mul through native bb build, all_cmds flow, to test all cli args.
    RUN FLOW=all_cmds ./run_acir_tests.sh 1_mul

acir-tests-bb-ultra-plonk:
    FROM +acir-tests-base
    # Run every acir test through native bb build prove_then_verify flow for UltraPlonk.
    # This ensures we test independent pk construction through real/garbage witness data paths.
    RUN FLOW=prove_then_verify ./run_acir_tests.sh
    RUN FLOW=prove_then_verify RECURSIVE=true ./run_acir_tests.sh assert_statement double_verify_proof

acir-tests-bb-ultra-honk:
    FROM +acir-tests-base
    # Run the acir test through native bb build prove_then_verify_ultra_honk flow
    # Note that the script will skip the Plonk related tests
    RUN FLOW=prove_then_verify_ultra_honk HONK=true ./run_acir_tests.sh
    RUN FLOW=prove_then_verify_ultra_honk HONK=true RECURSIVE=true ./run_acir_tests.sh assert_statement double_verify_honk_proof

    # Construct and verify a UltraHonk proof for a single program
    RUN FLOW=prove_and_verify_ultra_honk ./run_acir_tests.sh pedersen_hash
    # Construct and verify a MegaHonk proof on one non-recursive program using the new witness stack workflow
    RUN FLOW=prove_and_verify_ultra_honk_program ./run_acir_tests.sh merkle_insert
    # Construct and separately verify a UltraHonk proof for a single program that recursively verifies a Honk proof
    RUN FLOW=prove_then_verify_ultra_honk ./run_acir_tests.sh verify_honk_proof
    # Construct and verify a UltraHonk proof for a single program that recursively verifies a Honk proof
    RUN FLOW=prove_and_verify_ultra_honk ./run_acir_tests.sh verify_honk_proof

acir-tests-bb-mega-honk:
    FROM +acir-tests-base
    # Construct and separately verify a MegaHonk proof for all acir programs
    RUN FLOW=prove_then_verify_mega_honk ./run_acir_tests.sh
    # Construct and verify a MegaHonk proof for a single arbitrary program
    RUN FLOW=prove_and_verify_mega_honk ./run_acir_tests.sh 6_array
    # Construct and verify a MegaHonk proof for all ACIR programs using the new witness stack workflow
    RUN FLOW=prove_and_verify_mega_honk_program ./run_acir_tests.sh

acir-tests-sol:
    FROM +acir-tests-base
    COPY ./cpp/+preset-sol/ /usr/src/barretenberg/cpp/build
    RUN (cd sol-test && yarn)
    RUN FLOW=sol ./run_acir_tests.sh assert_statement double_verify_proof double_verify_nested_proof

acir-tests-sol-honk:
    FROM +acir-tests-base
    COPY ./cpp/+preset-sol/ /usr/src/barretenberg/cpp/build
    RUN (cd sol-test && yarn)
    RUN FLOW=honk_sol ./run_acir_tests.sh assert_statement 1_mul slices verify_honk_proof

acir-tests-bb.js:
    FROM +acir-tests-base
    # Build/install ts apps.
    RUN cd browser-test-app && yarn && yarn build
    RUN cd headless-test && yarn && npx playwright install && npx playwright install-deps
    RUN cd ../ts && yarn
    # We have diminishing returns after 32 cores, and unnecessarily use resources
    ENV HARDWARE_CONCURRENCY=32
    # TODO(https://github.com/AztecProtocol/aztec-packages/issues/6672): Try to enable double_verify
    # Run UltraHonk recursive verification through bb.js on chrome testing multi-threaded browser support.
    # TODO: Currently headless webkit doesn't seem to have shared memory so skipping multi-threaded test.
    RUN BROWSER=chrome THREAD_MODEL=mt ./run_acir_tests_browser.sh verify_honk_proof
    # Run UltraHonk recursive verification through bb.js on chrome testing single-threaded browser support.
    RUN BROWSER=chrome THREAD_MODEL=st ./run_acir_tests_browser.sh verify_honk_proof
    # Commenting for now as fails intermittently. Unreproducable on mainframe.
    # See https://github.com/AztecProtocol/aztec-packages/issues/2104
    #RUN BROWSER=webkit THREAD_MODEL=st ./run_acir_tests_browser.sh 1_mul
    # TODO(https://github.com/noir-lang/noir/issues/5106)
    # TODO(https://github.com/AztecProtocol/aztec-packages/issues/6672)
    # Run ecdsa_secp256r1_3x through bb.js on node to check 256k support.
    RUN BIN=../ts/dest/node/main.js FLOW=prove_then_verify ./run_acir_tests.sh ecdsa_secp256r1_3x
    # Run a single arbitrary test not involving recursion through bb.js for UltraHonk
    RUN BIN=../ts/dest/node/main.js FLOW=prove_and_verify_ultra_honk ./run_acir_tests.sh 6_array assert_statement
    # Run the prove then verify flow for UltraHonk. This makes sure we have the same circuit for different witness inputs.
    RUN BIN=../ts/dest/node/main.js FLOW=prove_then_verify_ultra_honk ./run_acir_tests.sh 6_array assert_statement
    # Run a single arbitrary test not involving recursion through bb.js for MegaHonk
    RUN BIN=../ts/dest/node/main.js FLOW=prove_and_verify_mega_honk ./run_acir_tests.sh 6_array
    # Run fold_basic test through bb.js which runs ClientIVC on fold basic
    RUN BIN=../ts/dest/node/main.js FLOW=fold_and_verify_program ./run_acir_tests.sh fold_basic
    # Run 1_mul through bb.js build, all_cmds flow, to test all cli args.
    RUN BIN=../ts/dest/node/main.js FLOW=all_cmds ./run_acir_tests.sh 1_mul

acir-tests:
    # cleaner output:
    WAIT
      BUILD +acir-tests-base
    END
    BUILD +acir-tests-bb
    BUILD +acir-tests-bb-ultra-plonk
    # WORKTODO make issue
    # BUILD +acir-tests-bb-ultra-honk
    BUILD +acir-tests-bb-mega-honk
    BUILD +acir-tests-sol
    BUILD +acir-tests-sol-honk
    BUILD +acir-tests-bb.js

acir-benches-bb:
  FROM ../+bootstrap-noir-bb
  WORKDIR /usr/src/barretenberg/acir_tests

bench-acir-bb:
  # This target is used for debugging the benchmarking target.
  # For precise benchmarks in CI use `bench-publish-acir-bb`
  FROM +acir-benches-bb
  RUN ./bench_acir_tests.sh

export-bench-acir-bb:
  ARG EARTHLY_GIT_HASH
  FROM +acir-benches-bb
  SAVE IMAGE aztecprotocol/barretenberg-acir-benches:$EARTHLY_GIT_HASH

bench-publish-acir-bb:
  ARG PULL_REQUEST
  ARG BRANCH
  ARG EARTHLY_GIT_HASH
  LOCALLY

  # Let docker compose know about the pushed tags above
  ENV AZTEC_DOCKER_TAG=$(git rev-parse HEAD)
  # Optimize to not cause serial behavior if image already exists
  IF ! docker image ls --format '{{.Repository}}:{{.Tag}}' | grep "aztecprotocol/barretenberg-acir-benches:$AZTEC_DOCKER_TAG"
    WAIT
      BUILD +export-bench-acir-bb
    END
  END

  RUN mkdir -p ./log
  RUN docker run -v "$(pwd)/log":/log -e LOG_FILE=/log/bench-acir.jsonl --rm aztecprotocol/barretenberg-acir-benches:$AZTEC_DOCKER_TAG ./bench_acir_tests.sh

  DO ../+UPLOAD_LOGS --PULL_REQUEST=$PULL_REQUEST --BRANCH=$BRANCH --COMMIT_HASH=$EARTHLY_GIT_HASH
