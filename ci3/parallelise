#!/usr/bin/env bash
# For running test cmds that are pathed relative to the repo root.
# Commands are read from stdin.
NO_CD=1 source $(git rev-parse --show-toplevel)/ci3/source

cd $root
num_cpus=$(get_num_cpus_max ${1:-})
parallel_args="-j$num_cpus --memsuspend $(memsuspend_limit) --line-buffer --joblog joblog.txt"

if [ "${NO_FAIL_FAST:-0}" -eq 0 ]; then
  parallel_args+=" --halt now,fail=1"
fi

echo "Starting test run using max $num_cpus cpus..."

# Init the cpu scheduling semaphore.
sem_sched init $num_cpus

output=$(mktemp)
trap 'rm -f $output' EXIT

# If we're in a terminal default to a progress bar, and use cache_log to save output to redis.
# Otherwise use denoise to display dots and save output to redis.
if [ -t 1 ]; then
  set +e
  parallel $parallel_args --bar "DUMP_FAIL=1 run_test_cmd {}" | DUP=1 cache_log "Test run" &> $output
  code=${PIPESTATUS[0]}
  if [ "$code" -ne 0 ]; then
    cat $output
    exit 1
  fi
  set -e
else
  denoise "parallel $parallel_args 'run_test_cmd {}' | tee $output"
fi

function filter_long_times {
    grep -E '\([0-9]+s\)$' |           # Match lines ending with (number)s
    sed 's/.*(\([0-9]\+\)s)$/\1 &/' |  # Extract number and keep original line
    awk '$1 > 300 {print $0}' |        # Filter for times > 300s
    sort -n |                          # Sort numerically by first column (time)
    sed 's/^[0-9]\+ //'                # Remove the extracted number used for sorting
}

slow_jobs=$(cat "$output" | filter_long_times)
if [ -n "$slow_jobs" ]; then
  echo -e "${yellow}WARNING: The following tests exceed 5 minute runtimes. Break them up or rethink them.${reset}"
  echo "$slow_jobs"
fi

echo "Completed run of $(tail -n+2 joblog.txt | wc -l) tests in $SECONDS seconds."
